# 浏览器原理

## parse

### mealy状态机

* 运用FSM来实现HTML分析
* 每个状态都是一个函数，十分方便在各个状态下操作相关的事情

### html解析生成dom树

parser接受HTML文本作为参数返回一颗dom树

* HTML标准Tokenization完整的定义HTML状态
* EOF: End Of Fileq
* 创建标签（开始标签，结束标签，自封闭标签）
* 创建元素，在各个状态中处理其逻辑创建元素，标签结束状态提交token
* 处理属性，属性值分单、双、无引号写法，状态较多，处理属性结束时将属性加到标签token上
* 通过使用栈，从标签构建dom树，遇到开始标签时创建元素并入栈，遇到结束标签时出栈
* 自封闭节点可视为入栈后立刻出栈
* 任何元素的父元素是它入栈前的栈顶
* 文本节点，与自封闭标签处理类似，多个文本节点需要合并

## css computing

* [css库](https://npmjs.com/package/css)解析css成AST
* 收集css规则
* 添加调用，调用位置在创建元素后立即计算css，理论上，分析一个元素时，所有css规则已经收集完毕，真实浏览器中，可能遇到body内的style标签，需要重新计算css。
* 重新计算css -> 重排 -> 重绘 （最佳实践：所有style标签尽量靠前，在所有标签之前）
* 计算css中，必须知道元素的所有父元素才能判断元素与规则匹配，判断顺序：先是当前元素，然后往外层父级找匹配
* 拆分选择器
* 根据选择器的类型和元素属性，计算匹配，复合选择器要再循环一层
* 权重比较（四元组```['行内', '#', '.', 'tagName']```）
